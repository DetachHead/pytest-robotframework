{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>pytest-robotframework</code> is a pytest plugin that creates robotframework reports for tests written in python and allows you to run robotframework tests with pytest.</p> <p></p>"},{"location":"#why-use-this","title":"Why use this?","text":"<p>you may want to use this plugin if any of the following applies to you:</p> <ul> <li>you want to use robotframework's reporting, but aren't a fan of the robot language and would prefer to write your tests in python</li> <li>your project contains both robotframework and pytest tests and you want to be able to run them both with the same tool</li> <li>you want to use other pytest plugins with your robotframework tests</li> </ul>"},{"location":"configuration/","title":"Configuration","text":"<p>pass <code>--capture=no</code> to make <code>logger.console</code> work properly.</p> <p>since this is a pytest plugin, you should avoid using robot options that have pytest equivalents:</p> instead of... use... notes <code>robot --include tag_name</code> <code>pytest -m tag_name</code> <code>robot --exclude tag_name</code> <code>pytest -m not tag_name</code> <code>robot --skip tag_name</code> <code>pytest -m \"not tag_name\"</code> <code>robot --test \"test name\" ./test.robot</code> <code>pytest ./test.robot::\"Test Name\"</code> <code>robot --suite \"suite name\" ./folder</code> <code>pytest ./folder</code> <code>robot --dryrun</code> <code>pytest --collect-only</code> not exactly the same. you should use a type checker on your python tests as a replacement for robot dryrun <code>robot --exitonfailure</code> <code>pytest --maxfail=1</code> <code>robot --rerunfailed</code> <code>pytest --lf</code> <code>robot --runemptysuite</code> <code>pytest --suppress-no-test-exit-code</code> requires the pytest-custom-exit-code plugin <code>robot --help</code> <code>pytest --help</code> all supported robot options will be listed in the <code>robotframework</code> section"},{"location":"configuration/#specifying-robot-options-directlty","title":"specifying robot options directlty","text":"<p>there are multiple ways you can specify the robot arguments directly. however, arguments that have pytest equivalents cannot be set with robot as they would cause the plugin to behave incorrectly.</p>"},{"location":"configuration/#pytest-cli-arguments","title":"pytest cli arguments","text":"<p>most robot cli arguments can be passed to pytest by prefixing the argument names with <code>--robot-</code>. for example, here's how to change the log level:</p>"},{"location":"configuration/#before","title":"before","text":"<pre><code>robot --loglevel DEBUG:INFO foo.robot\n</code></pre>"},{"location":"configuration/#after","title":"after","text":"<pre><code>pytest --robot-loglevel DEBUG:INFO test_foo.py\n</code></pre> <p>you can see a complete list of the available arguments using the <code>pytest --help</code> command. any robot arguments not present in that list are not supported because they are replaced by a pytest equivalent (see above).</p>"},{"location":"configuration/#pytest_robot_modify_options-hook","title":"<code>pytest_robot_modify_options</code> hook","text":"<p>you can specify a <code>pytest_robot_modify_options</code> hook in your <code>conftest.py</code> to programmatically modify the arguments. see the pytest_robotframework.hooks documentation for more information.</p> <pre><code>from pytest_robotframework import RobotOptions\nfrom robot.api.interfaces import ListenerV3\n\nclass Foo(ListenerV3):\n    ...\n\ndef pytest_robot_modify_options(options: RobotOptions, session: Session) -&gt; None:\n    if not session.config.option.collectonly:\n        options[\"loglevel\"] = \"DEBUG:INFO\"\n        options[\"listener\"].append(Foo()) # you can specify instances as listeners, prerebotmodifiers, etc.\n</code></pre> <p>note that not all arguments that the plugin passes to robot will be present in the <code>args</code> list. arguments required for the plugin to function (eg. the plugin's listeners and prerunmodifiers) cannot be viewed or modified with this hook</p>"},{"location":"configuration/#robot_options-environment-variable","title":"<code>ROBOT_OPTIONS</code> environment variable","text":"<pre><code>ROBOT_OPTIONS=\"-d results --listener foo.Foo\"\n</code></pre>"},{"location":"configuration/#enabling-pytest-assertions-in-the-robot-log","title":"enabling pytest assertions in the robot log","text":"<p>by default, only failed assertions will appear in the log. to make passed assertions show up, you'll have to add <code>enable_assertion_pass_hook = true</code> to your pytest ini options:</p> <pre><code># pyproject.toml\n[tool.pytest.ini_options]\nenable_assertion_pass_hook = true\n</code></pre> <p></p>"},{"location":"configuration/#hiding-non-user-facing-assertions","title":"hiding non-user facing assertions","text":"<p>you may have existing <code>assert</code> statements in your codebase that are not intended to be part of your tests (eg. for narrowing types/validating input data) and don't want them to show up in the robot log. there are two ways you can can hide individual <code>assert</code> statements from the log:</p> <pre><code>from pytest_robotframework import AssertOptions, hide_asserts_from_robot_log\n\ndef test_foo():\n    # hide a single passing `assert` statement:\n    assert foo == bar, AssertOptions(log_pass=False)\n\n    # hide a group of passing `assert` statements:\n    with hide_asserts_from_robot_log():\n        assert foo == bar\n        assert bar == baz\n</code></pre> <p>note that failing <code>assert</code> statements will still show in the log regardless.</p> <p>you can also run pytest with the <code>--no-assertions-in-robot-log</code> argument to disable <code>assert</code> statements in the robot log by default, then use <code>AssertOptions</code> to explicitly enable individual <code>assert</code> statements:</p> <pre><code>from pytest_robotframework import AssertOptions\n\ndef test_foo():\n    assert \"foo\" == \"bar\" # hidden from the robot log (when run with --no-assertions-in-robot-log)\n    assert \"bar\" == \"baz\", AssertOptions(log_pass=True) # not hidden\n</code></pre>"},{"location":"configuration/#customizing-assertions","title":"customizing assertions","text":"<p>pytest-robotframework allows you to customize the message for the <code>assert</code> keyword which appears on both passing and failing assertions:</p> <pre><code>assert 1 == 1  # no custom description\nassert 1 == 1, AssertOptions(description=\"custom description\")\n</code></pre> <p></p> <p>you can still pass a custom message to be displayed only when your assertion fails:</p> <pre><code>assert 1 == 2, \"the values did not match\"\n</code></pre> <p>however if you want to specify both a custom description and a failure message, you can use the <code>fail_message</code> argument:</p> <pre><code>assert 1 == 2, \"failure message\"\nassert 1 == 2, AssertOptions(description=\"checking values\", fail_message=\"failure message\")\n</code></pre> <p></p> <p>note that <code>enable_assertion_pass_hook</code> pytest option needs to be enabled for this to work.</p>"},{"location":"features/","title":"Features","text":""},{"location":"features/#write-robot-tests-in-python","title":"write robot tests in python","text":"<pre><code># you can use both robot and pytest features\nfrom robot.api import logger\nfrom pytest import Cache\n\nfrom pytest_robotframework import keyword\n\n@keyword  # make this function show as a keyword in the robot log\ndef foo():\n    ...\n\n@mark.slow  # markers get converted to robot tags\ndef test_foo():\n    foo()\n</code></pre>"},{"location":"features/#run-robot-tests","title":"run <code>.robot</code> tests","text":"<p>to allow for gradual adoption, the plugin also runs regular robot tests as well:</p> <pre><code>*** Settings ***\ntest setup  foo\n\n*** Test Cases ***\nbar\n    [Tags]  asdf  key:value\n    no operation\n\n*** Keywords ***\nfoo\n    log  ran setup\n</code></pre> <p>which is roughly equivalent to the following python code:</p> <pre><code># test_foo.py\nfrom pytest import mark\n\n@keyword\ndef foo():\n    logger.info(\"ran setup\")\n\n@fixture(autouse=True)\ndef setup():\n    foo()\n\n@mark.asdf\n@mark.key(\"value\")\ndef test_bar():\n    ...\n</code></pre>"},{"location":"features/#setupteardown","title":"setup/teardown","text":"<p>in pytest, setups and teardowns are defined using fixtures:</p> <pre><code>from pytest import fixture\nfrom robot.api import logger\n\n@fixture\ndef user():\n    logger.info(\"logging in\")\n    user = ...\n    yield user\n    logger.info(\"logging off\")\n\ndef test_something(user):\n    ...\n</code></pre> <p>under the hood, pytest calls the fixture setup/teardown code as part of the <code>pytest_runtest_setup</code> and and <code>pytest_runtest_teardown</code> hooks, which appear in the robot log like so:</p> <p></p> <p>for more information, see the pytest documentation for fixtures and hook functions.</p>"},{"location":"features/#tagsmarkers","title":"tags/markers","text":"<p>pytest markers are converted to tags in the robot log:</p> <pre><code>from pytest import mark\n\n@mark.slow\ndef test_blazingly_fast_sorting_algorithm():\n    [1,2,3].sort()\n</code></pre> <p></p> <p>markers like <code>skip</code>, <code>skipif</code> and <code>parameterize</code> also work how you'd expect:</p> <pre><code>from pytest import mark\n\n@mark.parametrize(\"test_input,expected\", [(1, 8), (6, 6)])\ndef test_eval(test_input: int, expected: int):\n    assert test_input == expected\n</code></pre> <p></p>"},{"location":"features/#robot-suite-variables","title":"robot suite variables","text":"<p>to set suite-level robot variables, call the <code>set_variables</code> function at the top of the test suite:</p> <pre><code>from robot.libraries.BuiltIn import BuiltIn\nfrom pytest_robotframework import set_variables\n\nset_variables(\n    {\n        \"foo\": \"bar\",\n        \"baz\": [\"a\", \"b\"],\n    }\n)\n\ndef test_variables():\n    assert BuiltIn().get_variable_value(\"$foo\") == \"bar\"\n</code></pre> <p><code>set_variables</code> is equivalent to the <code>*** Variables ***</code> section in a <code>.robot</code> file. all variables are prefixed with <code>$</code>. <code>@</code> and <code>&amp;</code> are not required since <code>$</code> variables can store lists and dicts anyway</p>"},{"location":"features/#running-tests-in-parallel","title":"running tests in parallel","text":"<p>running tests in parallel using pytest-xdist is supported. when running with xdist, pytest-robotframework will run separate instances of robot for each test, then merge the robot output files together automatically using rebot.</p>"},{"location":"ide-integrations/","title":"IDE integrations","text":""},{"location":"ide-integrations/#vscode","title":"vscode","text":"<p>vscode's builtin python plugin should discover both your python and robot tests by default, and show run buttons next to them:</p> <p> </p> <p>running <code>.robot</code> tests</p> <p>if you still intend to use <code>.robot</code> files with pytest-robotframework, we recommend using the robotcode extension and disabling its test explorer integration:</p> <p>.vscode/settings.json<pre><code>{\n    \"robotcode.testExplorer.enabled\": false\n}\n</code></pre> this will prevent the tests from being duplicated in the test explorer.</p>"},{"location":"ide-integrations/#pycharm","title":"pycharm","text":"<p>pycharm currently does not support pytest plugins for non-python files. see this issue</p>"},{"location":"installation/","title":"Installation","text":"<p>pytest will automatically find and activate the plugin once you install it.</p> uvcondapip <pre><code>uv add --dev pytest-robotframework\n</code></pre> <pre><code>conda install conda-forge::pytest-robotframework\n</code></pre> <pre><code>pip install pytest-robotframework\n</code></pre>"},{"location":"limitations/","title":"Limitations","text":"<p>there are some limitations when writing robotframework tests in python. pytest-robotframework includes solutions for these issues.</p>"},{"location":"limitations/#making-keywords-show-in-the-robot-log","title":"making keywords show in the robot log","text":"<p>by default when writing tests in python, the only keywords that you'll see in the robot log are <code>Setup</code>, <code>Run Test</code> and <code>Teardown</code>. this is because robot is not capable of recognizing keywords called outside of robot code. (see this issue)</p> <p>this plugin has several workarounds for the problem:</p>"},{"location":"limitations/#keyword-decorator","title":"<code>@keyword</code> decorator","text":"<p>if you want a function you wrote to show up as a keyword in the log, decorate it with the <code>pytest_robotframework.keyword</code> instead of <code>robot.api.deco.keyword</code></p> <pre><code>from pytest_robotframework import keyword\n\n@keyword\ndef foo():\n    ...\n</code></pre>"},{"location":"limitations/#pytest-functions-are-patched-by-the-plugin","title":"pytest functions are patched by the plugin","text":"<p>most of the pytest functions are patched so that they show as keywords in the robot log</p> <pre><code>def test_foo():\n    with pytest.raises(ZeroDivisionError):\n        logger.info(1 / 0)\n</code></pre> <p></p>"},{"location":"limitations/#patching-third-party-functions-with-keywordify","title":"patching third party functions with <code>keywordify</code>","text":"<p>if you want a function from a third party module/robot library to be displayed as a keyword, you can patch it with the <code>keywordify</code> function:</p> <pre><code># in your conftest.py\n\nfrom pyest_robotframework import keywordify\nimport some_module\n\n# patch a function from the module:\nkeywordify(some_module, \"some_function\")\n# works on classes too:\nkeywordify(some_module.SomeClass, \"some_method\")\n</code></pre>"},{"location":"limitations/#continuable-failures-dont-work","title":"continuable failures don't work","text":"<p>keywords that raise <code>ContinuableFailure</code> don't work properly when called from python code. this includes builtin keywords such as <code>Run Keyword And Continue On Failure</code>.</p> <p>use <code>pytest.raises</code> for expected failures instead:</p> <pre><code>from pytest import raises\n\nwith raises(SomeException):\n    some_keyword_that_fails()\n</code></pre> <p>or if the exception is conditionally raised, use a <code>try</code>/<code>except</code> statement like you would in regular python code:</p> <pre><code>try:\n    some_keyword_that_fails()\nexcept SomeException:\n    ... # ignore the exception, or re-raise it later\n</code></pre> <p>the keyword will still show as failed in the log (as long as it's decorated with <code>pytest_robotframework.keyword</code>), but it won't effect the status of the test unless the exception is re-raised.</p>"},{"location":"limitations/#why","title":"why?","text":"<p>robotframework introduced <code>TRY</code>/<code>EXCEPT</code> statements in version 5.0, which they now recommend using instead of the old <code>Run Keyword And Ignore Error</code>/<code>Run Keyword And Expect Error</code> keywords.</p> <p>however <code>TRY</code>/<code>EXCEPT</code> behaves differently to its python equivalent, as it allows for errors that do not actually raise an exception to be caught:</p> <pre><code>*** Test Cases ***\nFoo\n    TRY\n        Run Keyword And Continue On Failure    Fail\n        Log    this is executed\n    EXCEPT\n        Log    and so is this\n    END\n</code></pre> <p>this means that if control flows like <code>Run Keyword And Continue On Failure</code> were supported, its failures would be impossible to catch:</p> <pre><code>from robot.api.logger import info\nfrom robot.libraries.BuiltIn import BuiltIn\n\ntry:\n    BuiltIn().run_keyword_and_continue_on_failure(\"fail\")\n    info(\"this is executed because an exception was not actually raised\")\nexcept:\n    info(\"this is NOT executed, but the test will still fail\")\n</code></pre>"},{"location":"development/compatibility/","title":"Compatibility","text":"dependency version range comments python <code>&gt;=3.9,&lt;4.0</code> all versions of python will be supported until their end-of-life as described here robotframework <code>&gt;=6.1,&lt;8.0</code> i will try to support at least the two most recent major versions. robot 6.0 is not supported as the parser API that the plugin relies on to support tests written in python was introduced in version 6.1 pytest <code>&gt;=7.0,&lt;9.0</code> may work on other versions, but things may break since this plugin relies on some internal pytest modules"},{"location":"development/contributing/","title":"Contributing","text":"<p>unlike many projects, i try to make mine as easy as possible for other developers to work on by committing IDE config files and using tools such as pyprojectx to automate the installation of all the dev dependencies, so the steps to get set up are quite straightforward:</p>"},{"location":"development/contributing/#prerequisites","title":"prerequisites","text":"<ul> <li>python (&gt;=3.9)</li> <li>vscode (optional)</li> <li>shows inline errors for all linters used in the CI</li> <li>applies formatting fixes on save to prevent formatting errors from occurring in the CI</li> <li>there are tasks configured in the project to make installing dependencies and running tests more convenient</li> </ul>"},{"location":"development/contributing/#installation-steps","title":"installation steps","text":"<ol> <li>clone the repo</li> <li>run <code>./pw install</code></li> <li>if using vscode, click \"Yes\" when prompted to use the project venv and when prompted to install the recommended extensions</li> </ol>"},{"location":"development/contributing/#tests","title":"tests","text":"<p>since this is a pytest plugin, we have two types of tests:</p> <ul> <li>the plugin tests (located in <code>./tests/test_python.py</code> and <code>./tests/test_robot.py</code>) - these use pytester to run pytest against the fixture tests</li> <li>the \"fixture\" tests (<code>./tests/fixtures</code>) - the tests that the plugin tests run and validate the results of</li> </ul> <p>each plugin test is tied to a fixture test by the test name. for example, the following test runs the fixture test at <code>./tests/fixtures/test_python/test_one_test_passes.py</code>:</p> <pre><code># ./tests/test_python.py\ndef test_one_test_passes(pytester_dir: PytesterDir):\n    run_and_assert_result(pytester_dir, passed=1)\n    assert_log_file_exists(pytester_dir)\n</code></pre> <p>the <code>pytester_dir</code> fixture is an extension of pytester which gets the path to the current test file relative to the <code>tests</code> directory (<code>./test_python.py</code>) and ties it to a folder in <code>./tests/fixtures</code> with the same name (minus the <code>.py</code>, ie. <code>./tests/fixtures/test_python</code>), then looks for either a python or robot file in that directory with the same name as the test (<code>test_one_test_passes.py</code> or <code>test_one_test_passes.robot</code>), or a folder if the test requires multiple files.</p> <p>TL;DR: the test <code>tests/suite_name.py::test_name</code> looks in <code>tests/fixtures/suite_name</code> for a file called <code>test_name.py</code>, <code>test_name.robot</code> or a folder called <code>test_name</code>, then runs pytest with the robotframework plugin on the tests there</p>"},{"location":"reference/API/","title":"API","text":"<p>useful helpers for you to use in your pytest tests and <code>conftest.py</code> files</p>"},{"location":"reference/API/#pytest_robotframework.RobotVariables","title":"<code>RobotVariables: TypeAlias = dict[str, object]</code>","text":"<p>variable names and values to be set on the suite level. see the <code>set_variables</code> function</p>"},{"location":"reference/API/#pytest_robotframework.AssertOptions","title":"<code>AssertOptions</code>","text":"<p>pass this as the second argument to an <code>assert</code> statement to customize how it appears in the robot log.</p> <p>example: <pre><code>assert foo == bar, AssertOptions(\n    log_pass=False, description=\"checking the value\", fail_msg=\"assertion failed\"\n)\n</code></pre></p> Source code in <code>pytest_robotframework/__init__.py</code> <pre><code>class AssertOptions:\n    \"\"\"\n    pass this as the second argument to an `assert` statement to customize how it appears in the\n    robot log.\n\n    example:\n    ```python\n    assert foo == bar, AssertOptions(\n        log_pass=False, description=\"checking the value\", fail_msg=\"assertion failed\"\n    )\n    ```\n    \"\"\"\n\n    def __init__(\n        self,\n        *,\n        log_pass: bool | None = None,\n        description: str | None = None,\n        fail_message: str | None = None,\n    ) -&gt; None:\n        super().__init__()\n        self.log_pass: bool | None = log_pass\n        \"\"\"whether to display the assertion as a keyword in the robot log when it passes.\n\n        by default, a passing `assert` statement will display in the robot log as long as the\n        following conditions are met:\n        - the `enable_assertion_pass_hook` pytest option is enabled\n        - it is not inside a `hide_asserts_from_robot_log` context manager\n        (see [enabling pytest assertions in the robot log](https://github.com/DetachHead/pytest-robotframework/#enabling-pytest-assertions-in-the-robot-log)).\n        - pytest is not run with the `--no-asserts-in-robot-log` argument\n\n        failing `assert` statements will show as keywords in the log as long as the\n        `enable_assertion_pass_hook` pytest option is enabled. if it's disabled, the assertion error\n        will be logged, but not within a keyword.\n\n        example:\n        ```py\n        # (assuming all of these assertions pass)\n\n        # never displays in the robot log:\n        assert foo == bar, AssertOptions(log_pass=False)\n\n        # always displays in the robot log (as long as the `enable_assertion_pass_hook` pytest\n        # option is enabled):\n        assert foo == bar, AssertOptions(log_pass=True)\n\n        # displays in the robot log as only if all 3 conditions mentioned above are met:\n        assert foo == bar\n        ```\n        \"\"\"\n\n        self.description: str | None = description\n        \"\"\"normally, the asserted expression as it was written is displayed as the argument to the\n        `assert` keyword in the robot log, but setting this value will display a custom message\n        instead. when a custom description is used, the original expression is logged inside the\n        keyword instead.\"\"\"\n\n        self.fail_message: str | None = fail_message\n        \"\"\"optional description for the `assert` statement that will be included in the\n        `AssertionError` message if the assertion fails. equivalent to a normal `assert` statement's\n        second argument\"\"\"\n\n    @override\n    def __repr__(self) -&gt; str:\n        \"\"\"make the custom fail message appear in the call to `AssertionError`\"\"\"\n        return self.fail_message or \"\"\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.AssertOptions.description","title":"<code>description: str | None = description</code>","text":"<p>normally, the asserted expression as it was written is displayed as the argument to the <code>assert</code> keyword in the robot log, but setting this value will display a custom message instead. when a custom description is used, the original expression is logged inside the keyword instead.</p>"},{"location":"reference/API/#pytest_robotframework.AssertOptions.fail_message","title":"<code>fail_message: str | None = fail_message</code>","text":"<p>optional description for the <code>assert</code> statement that will be included in the <code>AssertionError</code> message if the assertion fails. equivalent to a normal <code>assert</code> statement's second argument</p>"},{"location":"reference/API/#pytest_robotframework.AssertOptions.log_pass","title":"<code>log_pass: bool | None = log_pass</code>","text":"<p>whether to display the assertion as a keyword in the robot log when it passes.</p> <p>by default, a passing <code>assert</code> statement will display in the robot log as long as the following conditions are met: - the <code>enable_assertion_pass_hook</code> pytest option is enabled - it is not inside a <code>hide_asserts_from_robot_log</code> context manager (see enabling pytest assertions in the robot log). - pytest is not run with the <code>--no-asserts-in-robot-log</code> argument</p> <p>failing <code>assert</code> statements will show as keywords in the log as long as the <code>enable_assertion_pass_hook</code> pytest option is enabled. if it's disabled, the assertion error will be logged, but not within a keyword.</p> <p>example: <pre><code># (assuming all of these assertions pass)\n\n# never displays in the robot log:\nassert foo == bar, AssertOptions(log_pass=False)\n\n# always displays in the robot log (as long as the `enable_assertion_pass_hook` pytest\n# option is enabled):\nassert foo == bar, AssertOptions(log_pass=True)\n\n# displays in the robot log as only if all 3 conditions mentioned above are met:\nassert foo == bar\n</code></pre></p>"},{"location":"reference/API/#pytest_robotframework.AssertOptions.__init__","title":"<code>__init__(*, log_pass: bool | None = None, description: str | None = None, fail_message: str | None = None) -&gt; None</code>","text":"Source code in <code>pytest_robotframework/__init__.py</code> <pre><code>def __init__(\n    self,\n    *,\n    log_pass: bool | None = None,\n    description: str | None = None,\n    fail_message: str | None = None,\n) -&gt; None:\n    super().__init__()\n    self.log_pass: bool | None = log_pass\n    \"\"\"whether to display the assertion as a keyword in the robot log when it passes.\n\n    by default, a passing `assert` statement will display in the robot log as long as the\n    following conditions are met:\n    - the `enable_assertion_pass_hook` pytest option is enabled\n    - it is not inside a `hide_asserts_from_robot_log` context manager\n    (see [enabling pytest assertions in the robot log](https://github.com/DetachHead/pytest-robotframework/#enabling-pytest-assertions-in-the-robot-log)).\n    - pytest is not run with the `--no-asserts-in-robot-log` argument\n\n    failing `assert` statements will show as keywords in the log as long as the\n    `enable_assertion_pass_hook` pytest option is enabled. if it's disabled, the assertion error\n    will be logged, but not within a keyword.\n\n    example:\n    ```py\n    # (assuming all of these assertions pass)\n\n    # never displays in the robot log:\n    assert foo == bar, AssertOptions(log_pass=False)\n\n    # always displays in the robot log (as long as the `enable_assertion_pass_hook` pytest\n    # option is enabled):\n    assert foo == bar, AssertOptions(log_pass=True)\n\n    # displays in the robot log as only if all 3 conditions mentioned above are met:\n    assert foo == bar\n    ```\n    \"\"\"\n\n    self.description: str | None = description\n    \"\"\"normally, the asserted expression as it was written is displayed as the argument to the\n    `assert` keyword in the robot log, but setting this value will display a custom message\n    instead. when a custom description is used, the original expression is logged inside the\n    keyword instead.\"\"\"\n\n    self.fail_message: str | None = fail_message\n    \"\"\"optional description for the `assert` statement that will be included in the\n    `AssertionError` message if the assertion fails. equivalent to a normal `assert` statement's\n    second argument\"\"\"\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.as_keyword","title":"<code>as_keyword(name: str, *, doc: str = '', tags: tuple[str, ...] | None = None, args: Iterable[str] | None = None, kwargs: Mapping[str, str] | None = None) -&gt; AbstractContextManager[None]</code>","text":"<p>runs the body as a robot keyword.</p> <p>example: <pre><code>with as_keyword(\"do thing\"):\n    ...\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>the name for the keyword</p> required <code>doc</code> <code>str</code> <p>the documentation to be displayed underneath the keyword in the robot log</p> <code>''</code> <code>tags</code> <code>tuple[str, ...] | None</code> <p>tags for the keyword</p> <code>None</code> <code>args</code> <code>Iterable[str] | None</code> <p>positional arguments to be displayed on the keyword in the robot log</p> <code>None</code> <code>kwargs</code> <code>Mapping[str, str] | None</code> <p>keyword arguments to be displayed on the keyword in the robot log</p> <code>None</code> Source code in <code>pytest_robotframework/__init__.py</code> <pre><code>def as_keyword(\n    name: str,\n    *,\n    doc: str = \"\",\n    tags: tuple[str, ...] | None = None,\n    args: Iterable[str] | None = None,\n    kwargs: Mapping[str, str] | None = None,\n) -&gt; AbstractContextManager[None]:\n    \"\"\"\n    runs the body as a robot keyword.\n\n    example:\n    ```py\n    with as_keyword(\"do thing\"):\n        ...\n    ```\n\n    :param name: the name for the keyword\n    :param doc: the documentation to be displayed underneath the keyword in the robot log\n    :param tags: tags for the keyword\n    :param args: positional arguments to be displayed on the keyword in the robot log\n    :param kwargs: keyword arguments to be displayed on the keyword in the robot log\n    \"\"\"\n\n    @_WrappedContextManagerKeywordDecorator(\n        name=name, tags=tags, doc=doc, module=\"\", max_argument_length_in_log=None\n    )\n    @contextmanager\n    def fn(*_args: str, **_kwargs: str) -&gt; Iterator[None]:\n        yield\n\n    return fn(*(args or []), **(kwargs or {}))\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.catch_errors","title":"<code>catch_errors(cls: _T_ListenerOrSuiteVisitor) -&gt; _T_ListenerOrSuiteVisitor</code>","text":"<p>errors that occur inside suite visitors and listeners do not cause the test run to fail. even <code>--exitonerror</code> doesn't catch every exception (see https://github.com/robotframework/robotframework/issues/4853).</p> <p>this decorator will remember any errors that occurred inside listeners and suite visitors, then raise them after robot has finished running.</p> <p>you don't need this if you are using the <code>listener</code> or <code>pre_rebot_modifier</code> decorator, as those decorators use <code>catch_errors</code> as well</p> Source code in <code>pytest_robotframework/__init__.py</code> <pre><code>def catch_errors(cls: _T_ListenerOrSuiteVisitor) -&gt; _T_ListenerOrSuiteVisitor:\n    \"\"\"\n    errors that occur inside suite visitors and listeners do not cause the test run to fail. even\n    `--exitonerror` doesn't catch every exception (see &lt;https://github.com/robotframework/robotframework/issues/4853&gt;).\n\n    this decorator will remember any errors that occurred inside listeners and suite visitors, then\n    raise them after robot has finished running.\n\n    you don't need this if you are using the `listener` or `pre_rebot_modifier` decorator, as\n    those decorators use `catch_errors` as well\n    \"\"\"\n    # prevent classes from being wrapped twice\n    marker = \"_catch_errors\"\n    if hasattr(cls, marker):\n        return cls\n\n    def wrapped(fn: Callable[P, T]) -&gt; Callable[P, T]:\n        @wraps(fn)\n        def inner(*args: P.args, **kwargs: P.kwargs) -&gt; T:\n            try:\n                return fn(*args, **kwargs)\n            except Exception as e:\n                item_or_session = current_item() or current_session()\n                if not item_or_session:\n                    raise InternalError(\n                        # stack trace isn't showsn so we neewd to include the original error in the\n                        # message as well\n                        f\"an error occurred inside {cls.__name__} and failed to get the\"\n                        f\" current pytest item/session: {e}\"\n                    ) from e\n                add_robot_error(item_or_session, str(e))\n                raise\n\n        return inner\n\n    for name, method in cast(\n        list[tuple[str, Function]],\n        inspect.getmembers(\n            cls,\n            predicate=lambda attr: inspect.isfunction(attr)  # pyright:ignore[reportAny]\n            # the wrapper breaks static methods idk why, but we shouldn't need to wrap them anyway\n            # because robot listeners/suite visitors don't call any static/class methods\n            and not isinstance(\n                inspect.getattr_static(cls, attr.__name__), (staticmethod, classmethod)\n            )\n            # only wrap methods that are overwritten on the subclass\n            and attr.__name__ in vars(cls)\n            # don't wrap private/dunder methods since they'll get called by the public ones and we\n            # don't want to duplicate errors\n            and not attr.__name__.startswith(\"_\"),\n        ),\n    ):\n        setattr(cls, name, wrapped(method))\n    setattr(cls, marker, True)\n    return cls\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.hide_asserts_from_robot_log","title":"<code>hide_asserts_from_robot_log() -&gt; Iterator[None]</code>","text":"<p>context manager for hiding multiple passing <code>assert</code> statements from the robot log. note that individual <code>assert</code> statements using <code>AssertOptions(log_pass=True)</code> take precedence, and that failing assertions will always appear in the log.</p> <p>when hiding only a single <code>assert</code> statement, you should use <code>AssertOptions(log=False)</code> instead.</p> <p>example: <pre><code>assert True  # not hidden\nwith hide_asserts_from_robot_log():\n    assert True  # hidden\n    assert True, AssertOptions(log_pass=True)  # not hidden\n</code></pre></p> Source code in <code>pytest_robotframework/__init__.py</code> <pre><code>@contextmanager\ndef hide_asserts_from_robot_log() -&gt; Iterator[None]:\n    \"\"\"\n    context manager for hiding multiple passing `assert` statements from the robot log. note that\n    individual `assert` statements using `AssertOptions(log_pass=True)` take precedence, and that\n    failing assertions will always appear in the log.\n\n    when hiding only a single `assert` statement, you should use `AssertOptions(log=False)` instead.\n\n    example:\n    ```py\n    assert True  # not hidden\n    with hide_asserts_from_robot_log():\n        assert True  # hidden\n        assert True, AssertOptions(log_pass=True)  # not hidden\n    ```\n    \"\"\"\n    item = current_item()\n    if not item:\n        raise InternalError(\n            # https://github.com/astral-sh/ty/issues/599\n            f\"failed to get current pytest item in {hide_asserts_from_robot_log.__name__}\"  # ty:ignore[unresolved-attribute]\n        )\n    previous_value = item.stash.get(_hide_asserts_context_manager_key, False)\n    item.stash[_hide_asserts_context_manager_key] = True\n    try:\n        yield\n    finally:\n        item.stash[_hide_asserts_context_manager_key] = previous_value\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.import_resource","title":"<code>import_resource(path: Path | str) -&gt; None</code>","text":"<p>imports the specified robot <code>.resource</code> file when the suite execution begins. use this when specifying robot resource imports at the top of the file.</p> <p>to import libraries, use a regular python import</p> Source code in <code>pytest_robotframework/__init__.py</code> <pre><code>def import_resource(path: Path | str) -&gt; None:\n    \"\"\"\n    imports the specified robot `.resource` file when the suite execution begins.\n    use this when specifying robot resource imports at the top of the file.\n\n    to import libraries, use a regular python import\n    \"\"\"\n    if execution_context():\n        BuiltIn().import_resource(escape_robot_str(str(path)))\n    else:\n        _resources.append(Path(path))\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.keyword","title":"<code>keyword(fn: Callable[P, T] | None = None, *, name: str | None = None, tags: tuple[str, ...] | None = None, module: str | None = None, wrap_context_manager: bool | None = None, max_argument_length_in_log: int | None = 100) -&gt; _KeywordDecorator | Callable[P, T]</code>","text":"<pre><code>keyword(\n    *,\n    name: str | None = ...,\n    tags: tuple[str, ...] | None = ...,\n    module: str | None = ...,\n    wrap_context_manager: Literal[True],\n    max_argument_length_in_log: int | None = ...,\n) -&gt; _WrappedContextManagerKeywordDecorator\n</code></pre><pre><code>keyword(\n    *,\n    name: str | None = ...,\n    tags: tuple[str, ...] | None = ...,\n    module: str | None = ...,\n    wrap_context_manager: Literal[False],\n    max_argument_length_in_log: int | None = ...,\n) -&gt; _NonWrappedContextManagerKeywordDecorator\n</code></pre><pre><code>keyword(\n    *,\n    name: str | None = ...,\n    tags: tuple[str, ...] | None = ...,\n    module: str | None = ...,\n    wrap_context_manager: None = ...,\n    max_argument_length_in_log: int | None = ...,\n) -&gt; _FunctionKeywordDecorator\n</code></pre><pre><code>keyword(fn: Callable[P, Never]) -&gt; Callable[P, Never]\n</code></pre><pre><code>keyword(\n    fn: Callable[P, AbstractContextManager[T]],\n) -&gt; Never\n</code></pre><pre><code>keyword(fn: Callable[P, T]) -&gt; Callable[P, T]\n</code></pre> <p>marks a function as a keyword and makes it show in the robot log.</p> <p>unlike robot's <code>deco.keyword</code> decorator, this one will make your function appear as a keyword in the robot log even when ran from a python file.</p> <p>if the function returns a context manager, its body is included in the keyword (just make sure the <code>@keyword</code> decorator is above <code>@contextmanager</code>)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | None</code> <p>set a custom name for the keyword in the robot log (default is inferred from the decorated function name). equivalent to <code>robot.api.deco.keyword</code>'s <code>name</code> argument</p> <code>None</code> <code>tags</code> <code>tuple[str, ...] | None</code> <p>equivalent to <code>robot.api.deco.keyword</code>'s <code>tags</code> argument</p> <code>None</code> <code>module</code> <code>str | None</code> <p>customize the module that appears top the left of the keyword name in the log. defaults to the function's actual module</p> <code>None</code> <code>wrap_context_manager</code> <code>bool | None</code> <p>if the decorated function returns a context manager, whether or not to wrap the context manager instead of the function. you probably always want this to be <code>True</code>, unless you don't always intend to use the returned context manager.</p> <code>None</code> <code>max_argument_length_in_log</code> <code>int | None</code> <p>unlike in <code>.robot</code> files, the runtime value of keyword arguments are rendered in the robot log (using its <code>__str__</code> method) instead of the expression from the source code. this can be noisy for some objects, so this parameter controls the the maximum number of characters to display before truncating it. set to <code>None</code> to disable the truncation.</p> <code>100</code> Source code in <code>pytest_robotframework/__init__.py</code> <pre><code>def keyword(  # pylint:disable=missing-param-doc\n    fn: Callable[P, T] | None = None,\n    *,\n    name: str | None = None,\n    tags: tuple[str, ...] | None = None,\n    module: str | None = None,\n    wrap_context_manager: bool | None = None,\n    max_argument_length_in_log: int | None = 100,\n) -&gt; _KeywordDecorator | Callable[P, T]:\n    \"\"\"\n    marks a function as a keyword and makes it show in the robot log.\n\n    unlike robot's `deco.keyword` decorator, this one will make your function appear as a keyword in\n    the robot log even when ran from a python file.\n\n    if the function returns a context manager, its body is included in the keyword (just make sure\n    the `@keyword` decorator is above `@contextmanager`)\n\n    :param name: set a custom name for the keyword in the robot log (default is inferred from the\n        decorated function name). equivalent to `robot.api.deco.keyword`'s `name` argument\n    :param tags: equivalent to `robot.api.deco.keyword`'s `tags` argument\n    :param module: customize the module that appears top the left of the keyword name in the log.\n        defaults to the function's actual module\n    :param wrap_context_manager: if the decorated function returns a context manager, whether or not\n        to wrap the context manager instead of the function. you probably always want this to be\n        `True`, unless you don't always intend to use the returned context manager.\n    :param max_argument_length_in_log: unlike in `.robot` files, the runtime value of keyword\n        arguments are rendered in the robot log (using its `__str__` method) instead of the\n        expression from the source code. this can be noisy for some objects, so this parameter\n        controls the the maximum number of characters to display before truncating it. set to `None`\n        to disable the truncation.\n    \"\"\"\n    if fn is None:\n        if wrap_context_manager is None:\n            return _FunctionKeywordDecorator(\n                name=name,\n                tags=tags,\n                module=module,\n                max_argument_length_in_log=max_argument_length_in_log,\n            )\n        if wrap_context_manager:\n            return _WrappedContextManagerKeywordDecorator(\n                name=name,\n                tags=tags,\n                module=module,\n                max_argument_length_in_log=max_argument_length_in_log,\n            )\n        return _NonWrappedContextManagerKeywordDecorator(\n            name=name,\n            tags=tags,\n            module=module,\n            max_argument_length_in_log=max_argument_length_in_log,\n        )\n    return keyword(  # pyright:ignore[reportReturnType] # ty:ignore[no-matching-overload]\n        name=name,\n        tags=tags,\n        module=module,\n        wrap_context_manager=wrap_context_manager,\n        max_argument_length_in_log=max_argument_length_in_log,\n    )(fn)  # pyright:ignore[reportArgumentType]\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.keywordify","title":"<code>keywordify(obj: object, method_name: str, *, name: str | None = None, tags: tuple[str, ...] | None = None, module: str | None = None, wrap_context_manager: bool = False) -&gt; None</code>","text":"<p>patches a function to make it show as a keyword in the robot log.</p> <p>you should only use this on third party modules that you don't control. if you want your own function to show as a keyword you should decorate it with <code>@keyword</code> instead (the one from this module, not the one from robot)</p> <p>Parameters:</p> Name Type Description Default <code>obj</code> <code>object</code> <p>the object with the method to patch on it (this has to be specified separately as the object itself needs to be modified with the patched method)</p> required <code>method_name</code> <code>str</code> <p>the name of the method to patch</p> required <code>name</code> <code>str | None</code> <p>set a custom name for the keyword in the robot log (default is inferred from the decorated function name). equivalent to <code>robot.api.deco.keyword</code>'s <code>name</code> argument</p> <code>None</code> <code>tags</code> <code>tuple[str, ...] | None</code> <p>equivalent to <code>robot.api.deco.keyword</code>'s <code>tags</code> argument</p> <code>None</code> <code>module</code> <code>str | None</code> <p>customize the module that appears top the left of the keyword name in the log. defaults to the function's actual module</p> <code>None</code> <code>wrap_context_manager</code> <code>bool</code> <p>if the decorated function returns a context manager, whether or not to wrap the context manager instead of the function. you probably always want this to be <code>True</code>, unless you don't always intend to use the returned context manager</p> <code>False</code> Source code in <code>pytest_robotframework/__init__.py</code> <pre><code>def keywordify(\n    obj: object,\n    method_name: str,\n    *,\n    name: str | None = None,\n    tags: tuple[str, ...] | None = None,\n    module: str | None = None,\n    wrap_context_manager: bool = False,\n) -&gt; None:\n    \"\"\"\n    patches a function to make it show as a keyword in the robot log.\n\n    you should only use this on third party modules that you don't control. if you want your own\n    function to show as a keyword you should decorate it with `@keyword` instead (the one from this\n    module, not the one from robot)\n\n    :param obj: the object with the method to patch on it (this has to be specified separately as\n    the object itself needs to be modified with the patched method)\n    :param method_name: the name of the method to patch\n    :param name: set a custom name for the keyword in the robot log (default is inferred from the\n    decorated function name). equivalent to `robot.api.deco.keyword`'s `name` argument\n    :param tags: equivalent to `robot.api.deco.keyword`'s `tags` argument\n    :param module: customize the module that appears top the left of the keyword name in the log.\n    defaults to the function's actual module\n    :param wrap_context_manager: if the decorated function returns a context manager, whether or not\n    to wrap the context manager instead of the function. you probably always want this to be `True`,\n    unless you don't always intend to use the returned context manager\n    \"\"\"\n    setattr(\n        obj,\n        method_name,\n        keyword(name=name, tags=tags, module=module, wrap_context_manager=wrap_context_manager)(\n            getattr(obj, method_name)  # pyright:ignore[reportAny]\n        ),\n    )\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.set_variables","title":"<code>set_variables(variables: RobotVariables) -&gt; None</code>","text":"<p>sets suite-level variables, equivalent to the <code>*** Variables ***</code> section in a <code>.robot</code> file.</p> <p>also performs some validation checks that robot doesn't to make sure the variable has the correct type matching its prefix.</p> Source code in <code>pytest_robotframework/__init__.py</code> <pre><code>def set_variables(variables: RobotVariables) -&gt; None:\n    \"\"\"\n    sets suite-level variables, equivalent to the `*** Variables ***` section in a `.robot` file.\n\n    also performs some validation checks that robot doesn't to make sure the variable has the\n    correct type matching its prefix.\n    \"\"\"\n    suite_path = Path(inspect.stack()[1].filename)\n    _suite_variables[suite_path] = variables\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.RobotOptions","title":"<code>RobotOptions</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>robot command-line arguments after being parsed by robot into a <code>dict</code>.</p> <p>for example, the following robot options:</p> <pre><code>ROBOT_OPTIONS=\"--listener Foo --listener Bar -d baz\"\n</code></pre> <p>will be converted to a <code>dict</code> like so: <pre><code>{\"listener\": [\"Foo\", \"Bar\"], \"outputdir\": \"baz\"}\n</code></pre></p> <p>any options missing from this <code>TypedDict</code> are not allowed to be modified as they interfere with the functionality of this plugin. see configuration for alternatives</p> Source code in <code>pytest_robotframework/_internal/robot/utils.py</code> <pre><code>class RobotOptions(TypedDict):\n    \"\"\"\n    robot command-line arguments after being parsed by robot into a `dict`.\n\n    for example, the following robot options:\n\n    ```dotenv\n    ROBOT_OPTIONS=\"--listener Foo --listener Bar -d baz\"\n    ```\n\n    will be converted to a `dict` like so:\n    ```py\n    {\"listener\": [\"Foo\", \"Bar\"], \"outputdir\": \"baz\"}\n    ```\n\n    any options missing from this `TypedDict` are not allowed to be modified as they interfere with\n    the functionality of this plugin. see [configuration](../configuration.md)\n    for alternatives\n    \"\"\"\n\n    rpa: bool | None\n    language: str | None\n    extension: str\n    name: str | None\n    doc: str | None\n    metadata: list[str]\n    settag: list[str]\n    rerunfailedsuites: list[str] | None\n    skiponfailure: list[str]\n    variable: list[str]\n    variablefile: list[str]\n    outputdir: str\n    output: str | None\n    log: str | None\n    report: str | None\n    xunit: str | None\n    debugfile: str | None\n    timestampoutputs: bool\n    splitlog: bool\n    logtitle: str | None\n    reporttitle: str | None\n    reportbackground: tuple[str, str] | tuple[str, str, str]\n    maxerrorlines: int | None\n    maxassignlength: int\n    loglevel: str\n    suitestatlevel: int\n    tagstatinclude: list[str]\n    tagstatexclude: list[str]\n    tagstatcombine: list[str]\n    tagdoc: list[str]\n    tagstatlink: list[str]\n    expandkeywords: list[str]\n    removekeywords: list[str]\n    flattenkeywords: list[str]\n    listener: list[str | Listener]\n    statusrc: bool\n    skipteardownonexit: bool\n    prerunmodifier: list[str | model.SuiteVisitor]\n    prerebotmodifier: list[str | model.SuiteVisitor]\n    randomize: Literal[\"ALL\", \"SUITES\", \"TESTS\", \"NONE\"]\n    console: Literal[\"verbose\", \"dotted\", \"quiet\", \"none\"]\n    \"\"\"the default in robot is `\"verbose\", however pytest-robotframework changes the default to\n    `\"quiet\"`, if you change this, then pytest and robot outputs will overlap.\"\"\"\n    dotted: bool\n    quiet: bool\n    consolewidth: int\n    consolecolors: Literal[\"AUTO\", \"ON\", \"ANSI\", \"OFF\"]\n    consolelinks: Literal[\"AUTO\", \"OFF\"]\n    \"\"\"only available in robotframework &gt;=7.1.\n\n    currently does nothing. see https://github.com/DetachHead/pytest-robotframework/issues/305\"\"\"\n    consolemarkers: Literal[\"AUTO\", \"ON\", \"OFF\"]\n    pythonpath: list[str]\n    # argumentfile is not supported because it's not in the _cli_opts dict for some reason\n    # argumentfile: str | None  # noqa: ERA001\n    parser: list[str | Parser]\n    legacyoutput: bool\n    parseinclude: list[str]\n    stdout: object  # no idea what this is, it's not in the robot docs\n    stderr: object  # no idea what this is, it's not in the robot docs\n    exitonerror: bool\n</code></pre>"},{"location":"reference/API/#pytest_robotframework.RobotOptions.console","title":"<code>console: Literal['verbose', 'dotted', 'quiet', 'none']</code>","text":"<p>the default in robot is <code>\"verbose\", however pytest-robotframework changes the default to</code>\"quiet\"`, if you change this, then pytest and robot outputs will overlap.</p>"},{"location":"reference/API/#pytest_robotframework.RobotOptions.consolecolors","title":"<code>consolecolors: Literal['AUTO', 'ON', 'ANSI', 'OFF']</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.consolelinks","title":"<code>consolelinks: Literal['AUTO', 'OFF']</code>","text":"<p>only available in robotframework &gt;=7.1.</p> <p>currently does nothing. see https://github.com/DetachHead/pytest-robotframework/issues/305</p>"},{"location":"reference/API/#pytest_robotframework.RobotOptions.consolemarkers","title":"<code>consolemarkers: Literal['AUTO', 'ON', 'OFF']</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.consolewidth","title":"<code>consolewidth: int</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.debugfile","title":"<code>debugfile: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.doc","title":"<code>doc: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.dotted","title":"<code>dotted: bool</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.exitonerror","title":"<code>exitonerror: bool</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.expandkeywords","title":"<code>expandkeywords: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.extension","title":"<code>extension: str</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.flattenkeywords","title":"<code>flattenkeywords: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.language","title":"<code>language: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.legacyoutput","title":"<code>legacyoutput: bool</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.listener","title":"<code>listener: list[str | Listener]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.log","title":"<code>log: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.loglevel","title":"<code>loglevel: str</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.logtitle","title":"<code>logtitle: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.maxassignlength","title":"<code>maxassignlength: int</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.maxerrorlines","title":"<code>maxerrorlines: int | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.metadata","title":"<code>metadata: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.name","title":"<code>name: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.output","title":"<code>output: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.outputdir","title":"<code>outputdir: str</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.parseinclude","title":"<code>parseinclude: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.parser","title":"<code>parser: list[str | Parser]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.prerebotmodifier","title":"<code>prerebotmodifier: list[str | model.SuiteVisitor]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.prerunmodifier","title":"<code>prerunmodifier: list[str | model.SuiteVisitor]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.pythonpath","title":"<code>pythonpath: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.quiet","title":"<code>quiet: bool</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.randomize","title":"<code>randomize: Literal['ALL', 'SUITES', 'TESTS', 'NONE']</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.removekeywords","title":"<code>removekeywords: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.report","title":"<code>report: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.reportbackground","title":"<code>reportbackground: tuple[str, str] | tuple[str, str, str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.reporttitle","title":"<code>reporttitle: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.rerunfailedsuites","title":"<code>rerunfailedsuites: list[str] | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.rpa","title":"<code>rpa: bool | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.settag","title":"<code>settag: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.skiponfailure","title":"<code>skiponfailure: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.skipteardownonexit","title":"<code>skipteardownonexit: bool</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.splitlog","title":"<code>splitlog: bool</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.statusrc","title":"<code>statusrc: bool</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.stderr","title":"<code>stderr: object</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.stdout","title":"<code>stdout: object</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.suitestatlevel","title":"<code>suitestatlevel: int</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.tagdoc","title":"<code>tagdoc: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.tagstatcombine","title":"<code>tagstatcombine: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.tagstatexclude","title":"<code>tagstatexclude: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.tagstatinclude","title":"<code>tagstatinclude: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.tagstatlink","title":"<code>tagstatlink: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.timestampoutputs","title":"<code>timestampoutputs: bool</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.variable","title":"<code>variable: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.variablefile","title":"<code>variablefile: list[str]</code>","text":""},{"location":"reference/API/#pytest_robotframework.RobotOptions.xunit","title":"<code>xunit: str | None</code>","text":""},{"location":"reference/API/#pytest_robotframework.Listener","title":"<code>Listener = Union[ListenerV2, ListenerV3]</code>","text":""},{"location":"reference/hooks/","title":"Hooks","text":"<p>new pytest hooks defined by the <code>pytest_robotframework</code> plugin. these are not to be imported. see the documentation for pytest hook functions for information on how to use them.</p>"},{"location":"reference/hooks/#pytest_robotframework._internal.pytest.hooks.pytest_robot_assertion","title":"<code>pytest_robot_assertion(item: Item, expression: str, fail_message: object, line_number: int, assertion_error: AssertionError | None, explanation: str) -&gt; None</code>","text":"<p>gets called when an assertion runs. unlike <code>pytest_assertrepr_compare</code> and <code>pytest_assertion_pass</code>, this hook is executed on both passing and failing assertions, and allows you to see the second argument passed to <code>assert</code> statement</p> <p>requires the <code>enable_assertion_pass_hook</code> pytest option to be enabled</p> <p>Warning</p> <p>this hook is experimental and relies heavily on patching the internals of pytest. it may break, change or be removed at any time. you should only use this hook if you know what you're doing</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>Item</code> <p>the currently running item</p> required <code>expression</code> <code>str</code> <p>a string containing the the source code of the expression passed to the <code>assert</code> statement</p> required <code>fail_message</code> <code>object</code> <p>the second argument to the <code>assert</code> statement, or <code>None</code> if there was none provided</p> required <code>line_number</code> <code>int</code> <p>the line number containing the <code>assert</code> statement</p> required <code>assertion_error</code> <code>AssertionError | None</code> <p>the exception raised if the <code>assert</code> statement failed. <code>None</code> if the assertion passed. you must re-raise the assertion error for the assertion to fail (useful if you want to conditionally ignore an assertion error)</p> required <code>explanation</code> <code>str</code> <p>pytest's explanation of the result. the format will be different depending on whether the assertion passed or failed</p> required Source code in <code>pytest_robotframework/_internal/pytest/hooks.py</code> <pre><code>@hookspec\ndef pytest_robot_assertion(\n    item: Item,\n    expression: str,\n    fail_message: object,\n    line_number: int,\n    assertion_error: AssertionError | None,\n    explanation: str,\n) -&gt; None:\n    \"\"\"\n    gets called when an assertion runs. unlike `pytest_assertrepr_compare` and\n    `pytest_assertion_pass`, this hook is executed on both passing and failing assertions, and\n    allows you to see the second argument passed to `assert` statement\n\n    requires the `enable_assertion_pass_hook` pytest option to be enabled\n\n    !!! warning\n        this hook is experimental and relies heavily on patching the internals of pytest. it may\n        break, change or be removed at any time. you should only use this hook if you know what\n        you're doing\n\n    :param item:\n        the currently running item\n    :param expression:\n        a string containing the the source code of the expression passed to the `assert` statement\n    :param fail_message:\n        the second argument to the `assert` statement, or `None` if there was none provided\n    :param line_number:\n        the line number containing the `assert` statement\n    :param assertion_error:\n        the exception raised if the `assert` statement failed. `None` if the assertion passed.\n        you must re-raise the assertion error for the assertion to fail (useful if you want to\n        conditionally ignore an assertion error)\n    :param explanation:\n        pytest's explanation of the result. the format will be different depending on whether the\n        assertion passed or failed\n    \"\"\"\n</code></pre>"},{"location":"reference/hooks/#pytest_robotframework._internal.pytest.hooks.pytest_robot_modify_options","title":"<code>pytest_robot_modify_options(options: RobotOptions, session: Session) -&gt; None</code>","text":"<p>modify the arguments passed to robot in-place</p> <p>example: <pre><code>def pytest_robot_modify_options(options: RobotOptions, session: Session) -&gt; None:\nif not session.config.option.collectonly:\n    options[\"loglevel\"] = \"DEBUG:INFO\"\n    options[\"listener\"].append(Foo())\n</code></pre></p> <p>Parameters:</p> Name Type Description Default <code>options</code> <code>RobotOptions</code> <p>the arguments to be passed to robot in dict format. for example, <code>{\"listener\": [\"Foo\", \"Bar\"]}</code>means <code>--listener Foo --listener Bar</code>). you can also specify instances of classes to <code>listener</code> and <code>prerebotmodifier</code></p> required <code>session</code> <code>Session</code> <p>the pytest <code>Session</code> object</p> required Source code in <code>pytest_robotframework/_internal/pytest/hooks.py</code> <pre><code>@hookspec\ndef pytest_robot_modify_options(options: RobotOptions, session: Session) -&gt; None:\n    \"\"\"\n    modify the arguments passed to robot in-place\n\n    example:\n    ```py\n    def pytest_robot_modify_options(options: RobotOptions, session: Session) -&gt; None:\n    if not session.config.option.collectonly:\n        options[\"loglevel\"] = \"DEBUG:INFO\"\n        options[\"listener\"].append(Foo())\n    ```\n\n    :param options: the arguments to be passed to robot in dict format. for example,\n    `{\"listener\": [\"Foo\", \"Bar\"]}`means `--listener Foo --listener Bar`). you can also specify\n    instances of classes to `listener` and `prerebotmodifier`\n    :param session: the pytest `Session` object\n    \"\"\"\n</code></pre>"}]}